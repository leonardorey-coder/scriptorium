{
  "titulo": "Algoritmos de ordenamiento en Java",
  "tipo": "investigacion",
  "materia": "programacion visual",
  "presenta": "CRUZ FLORES JUAN LEONARDO",
  "profesor": "CUEVAS HERNÁNDEZ ALDO ISMAEL",
  "introduccion": "En esta investigación se analizarán y desarrollarán diferentes algoritmos de ordenamiento utilizando el lenguaje de programación Java. Entre los algoritmos estudiados se encuentran: Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, Quick Sort y Heap Sort. Estos métodos son fundamentales para la organización de datos, permitiendo una mayor eficiencia en el manejo y procesamiento de grandes volúmenes de información. Se abordará el funcionamiento de cada algoritmo, su implementación en Java y su eficiencia en términos de complejidad temporal y espacial. También se explicará cómo elegir el algoritmo adecuado dependiendo del contexto y los datos a ordenar.",
  "desarrollo": "El primer paso de esta investigación fue comprender el funcionamiento teórico de cada algoritmo de ordenamiento. Se inició con los métodos más básicos: Bubble Sort, Selection Sort e Insertion Sort. Estos algoritmos son de tipo iterativo y tienen una complejidad temporal promedio de O(n²), por lo que se utilizan principalmente con conjuntos de datos pequeños.  \n\n1. **Bubble Sort:** Este algoritmo compara elementos adyacentes y los intercambia si están en el orden incorrecto. En Java, se implementó utilizando dos bucles anidados que recorren el arreglo y realizan los intercambios necesarios. Se agregó una bandera para detener el proceso si no se realizan intercambios en una iteración, optimizando el tiempo de ejecución.  \n\n2. **Selection Sort:** Funciona seleccionando el elemento más pequeño del arreglo y colocándolo en su posición correcta. En su implementación, se utilizó un bucle anidado, donde el bucle externo recorre el arreglo y el interno busca el valor mínimo. Posteriormente, se intercambia el elemento mínimo con el elemento en la posición actual del bucle externo.  \n\n3. **Insertion Sort:** Este algoritmo ordena elementos de forma similar a cómo se organizan las cartas en la mano. Se implementó recorriendo el arreglo desde el segundo elemento, comparándolo con los elementos anteriores y colocándolo en la posición correcta.  \n\nPosteriormente, se estudiaron los algoritmos más avanzados: Merge Sort, Quick Sort y Heap Sort. Estos métodos son más eficientes, con una complejidad promedio de O(n log n), y se utilizan para ordenar grandes conjuntos de datos.  \n\n4. **Merge Sort:** Este algoritmo divide el arreglo en mitades, las ordena de forma recursiva y luego las combina en un solo arreglo ordenado. Se implementó utilizando recursión para dividir el arreglo y un método auxiliar para fusionar las mitades ordenadas.  \n\n5. **Quick Sort:** Se selecciona un elemento como pivote y se divide el arreglo en dos partes: elementos menores al pivote y elementos mayores al pivote. Luego, se aplica recursión para ordenar las subpartes. En Java, se implementó utilizando un método para particionar el arreglo y otro para realizar las llamadas recursivas.  \n\n6. **Heap Sort:** Convierte el arreglo en un heap máximo, luego extrae el elemento raíz (el mayor) y lo coloca al final del arreglo. Este proceso se repite hasta que el arreglo esté ordenado. Se implementó utilizando un método para construir el heap y otro para realizar los intercambios.  \n\nAdemás, se hizo un análisis comparativo de los algoritmos, evaluando su desempeño en arreglos con diferentes tamaños y distribuciones de datos (ordenados, inversamente ordenados y aleatorios). Los resultados mostraron que, para conjuntos pequeños, Insertion Sort fue el más rápido debido a su bajo overhead, pero para conjuntos grandes, Quick Sort y Merge Sort ofrecieron un mejor rendimiento.",
  "conclusion": "La implementación de algoritmos de ordenamiento en Java permite comprender las bases de la manipulación de datos y la importancia de elegir el método adecuado según el contexto. Estos algoritmos no solo son herramientas fundamentales en la programación, sino que también enseñan conceptos clave como la recursión, la gestión de memoria y la optimización de procesos. A través de esta investigación, se logró implementar, probar y analizar cada uno de los algoritmos estudiados, destacando sus fortalezas y debilidades en diferentes escenarios. Se concluye que, aunque los algoritmos básicos son más simples de entender e implementar, los avanzados son esenciales para abordar problemas con grandes volúmenes de datos, garantizando una mayor eficiencia y desempeño."
}